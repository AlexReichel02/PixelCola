{% extends "base.html" %} {% block title %}Home{% endblock %}
{% block content
%}
<link rel="stylesheet" type="text/css" href="../static/gamev2Style.css">

<br />
<br />


<div class="banner" id="banner">

    <p> Welcome {{ user.email }}</p>
    <p>Current Score: <span id="current-score">{{ user.score }}</span></p>
    <p> Current Level: <span id="current-level">{{ user.level }}</span> </p>

</div>

<div class="section">
    {% if user.level < 1 %} <h5>NOT ENOUGH POINTS!</h5>

        {% else %}
        <p>game!</p>
        {% endif %}

</div>


<br />
<br />
<br />
<canvas id="tetrisCanvas"></canvas>

</body>

</html>

<script>
    let canvas;
    let ctx;
    let gBArrayHeight = 20;
    let gBArrayWidth = 12;
    let startX = 4;
    let startY = 0;
    let bottomX = 0;
    let bottomY = 20
    let score = 0;
    let level = 1;
    let winOrLose = "Playing";
    let coordinateArray = [...Array(gBArrayHeight)].map(e => Array(gBArrayWidth).fill(0));
    let curTetromino = [[1, 0], [0, 1], [1, 1], [2, 1]];
    let baseTetromino = [[1, 0], [0, 1], [1, 1], [2, 1]];
    let tetrominos = [];
    let tetrominoColors = ['orange'];
    let curTetrominoColor;
    let gameBoardArray = [...Array(gBArrayHeight)].map(e => Array(gBArrayWidth).fill(0));
    let stoppedShapeArray = [...Array(gBArrayHeight)].map(e => Array(gBArrayWidth).fill(0));
    let DIRECTION = {
        IDLE: 0,
        DOWN: 1,
        LEFT: 2,
        RIGHT: 3
    };
    let direction;


    class Coordinates {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }

    document.addEventListener('DOMContentLoaded', SetupCanvas);

    function CreateCoordArray() {
        let i = 0;
        let j = 0;
        
        //This builds the Coordinates Array.
        for (let y = 9; y <= 446; y += 23) {                    //446 px
            for (let x = 11; x <= 264; x += 23) {               //264 px
                coordinateArray[i][j] = new Coordinates(x, y);
                i++;
            }
            j++;
            i = 0;
        }
    }

    function SetupCanvas() {
        canvas = document.getElementById('tetrisCanvas');
        ctx = canvas.getContext('2d');
        canvas.width = 936;                                 //590 px
        canvas.height = 956;                                //580 px

        ctx.scale(2, 2);                                    //zooms and makes things bigger
        
        ctx.fillStyle = 'white';                            //canvas background fill after the block moves down
        ctx.fillRect(0, 0, canvas.width, canvas.height);    //canvas top end color the erases as block moves down

        ctx.strokeStyle = 'black';                          // font and color for the following and black border around gameboard
        ctx.strokeRect(8, 8, 280, 462);                     // 1,1,293,288 positioning of the black border

        ctx.fillStyle = 'black';                            //Score color and level color
        ctx.font = '21px Arial';
        ctx.fillText("SCORE", 300, 98);
        ctx.strokeRect(300, 107, 161, 24);
        ctx.fillText(score.toString(), 310, 127);

        ctx.fillText("LEVEL", 300, 157);                    //Level and black box
        ctx.strokeRect(300, 171, 161, 24);
        ctx.fillText(level.toString(), 310, 190);

        ctx.fillText("WIN / LOSE", 300, 221);               // Playing or Game Over
        ctx.fillText(winOrLose, 310, 261);
        ctx.strokeRect(300, 232, 161, 95);

        document.addEventListener('keydown', HandleKeyPress);
        CreateTetrominos();                                 // Creates array and pushes block into it
        CreateTetromino();                                  // selects a random tetromino

        CreateCoordArray();                                 // Creates the coord array
        //BaseBlocks();
        DrawTetromino();                                    // Draw the actual tetromino
    }

    function BaseBlocks(){

        for(let i = 0; i < baseTetromino.length; i++){
            let xb = baseTetromino[i][0] + bottomX;
            let yb = baseTetromino[i][1] + bottomY;
            gameBoardArray[xb][yb] = 1;
            let coorX = coordinateArray[xb][yb].xb;
            let coorY = coordinateArray[xb][yb].yb;
            ctx.fillStyle = curTetrominoColor;
            ctx.fillRect(coorX, coorY, 23,23);
            
        }
    }

    function DrawTetromino() {
        
        for (let i = 0; i < curTetromino.length; i++) {
            let x = curTetromino[i][0] + startX;
            let y = curTetromino[i][1] + startY;
            gameBoardArray[x][y] = 1;
            let coorX = coordinateArray[x][y].x;
            let coorY = coordinateArray[x][y].y;
            ctx.fillStyle = curTetrominoColor;
            ctx.fillRect(coorX, coorY, 23,23); //tetromino square sizes 23,23
        }
    }

    function HandleKeyPress(key) {
        if (winOrLose != "Game Over") {
            if (key.keyCode === 65) {
                direction = DIRECTION.LEFT;
                if (!HittingTheWall() && !CheckForHorizontalCollision()) {
                    DeleteTetromino();
                    startX--;
                    DrawTetromino();
                }

            } else if (key.keyCode === 68) {
                direction = DIRECTION.RIGHT;
                if (!HittingTheWall() && !CheckForHorizontalCollision()) {
                    DeleteTetromino();
                    startX++;
                    DrawTetromino();
                }

            } else if (key.keyCode === 83) {
                MoveTetrominoDown();
            }
        }
    }

    function MoveTetrominoDown() {
        direction = DIRECTION.DOWN;
        if (!CheckForVerticalCollision()) {
            DeleteTetromino();
            startY++;
            DrawTetromino();
        }
    }

    function DeleteTetromino() {
        for (let i = 0; i < curTetromino.length; i++) {
            let x = curTetromino[i][0] + startX;
            let y = curTetromino[i][1] + startY;
            gameBoardArray[x][y] = 0;
            let coorX = coordinateArray[x][y].x;
            let coorY = coordinateArray[x][y].y;
            ctx.fillStyle = 'white';
            ctx.fillRect(coorX, coorY, 23,23);
        }
    }

    function CreateTetrominos() {
        tetrominos.push([[0, 0], [1, 0], [0, 1], [1, 1]]);


    }

    function CreateTetromino() {
        let randomTetromino = Math.floor(Math.random() * tetrominos.length);
        curTetromino = tetrominos[randomTetromino];
        curTetrominoColor = tetrominoColors[randomTetromino];
    }

    function HittingTheWall() {
        for (let i = 0; i < curTetromino.length; i++) {
            let newX = curTetromino[i][0] + startX;
            if (newX <= 0 && direction === DIRECTION.LEFT) {
                return true;

            } else if (newX >= 11 && direction === DIRECTION.RIGHT) {
                return true;
            }
        }
        return false;
    }

    function CheckForVerticalCollision() {
        let tetrominoCopy = curTetromino;
        let collision = false;
        for (let i = 0; i < tetrominoCopy.length; i++) {
            let square = tetrominoCopy[i];
            let x = square[0] + startX;
            let y = square[1] + startY;
            if (direction === DIRECTION.DOWN) {
                y++;
            }
            if (typeof stoppedShapeArray[x][y + 1] === 'string') {
                DeleteTetromino();
                startY++;
                DrawTetromino();
                collision = true;
                break;
            }
            if (y >= 20) {
                collision = true;
                break;
            }


        }
        if (collision) {
            if (startY <= 2) {
                winOrLose = "Game Over";
                ctx.fillStyle = 'white';
                ctx.fillRect(310, 242, 140, 30);
                ctx.fillStyle = 'black';
                ctx.fillText(winOrLose, 310, 261);
            } else {
                for (let i = 0; i < tetrominoCopy.length; i++) {
                    let square = tetrominoCopy[i];
                    let x = square[0] + startX;
                    let y = square[1] + startY;
                    stoppedShapeArray[x][y] = curTetrominoColor;
                }
                CheckForCompletedRows();
                CreateTetromino();
                direction = DIRECTION.IDLE;
                startX = 4;
                startY = 0;
                DrawTetromino();
            }
        }

    }

    function CheckForHorizontalCollision() {
        var tetrominoCopy = curTetromino;
        var collision = false;
        for (var i = 0; i < tetrominoCopy.length; i++) {
            var square = tetrominoCopy[i];
            var x = square[0] + startX;
            var y = square[1] + startY;
            if (direction == DIRECTION.LEFT) {
                x--;
            } else if (direction == DIRECTION.RIGHT) {
                x++;
            }
            var stoppedShapeVal = stoppedShapeArray[x][y];
            if (typeof stoppedShapeVal === 'string') {
                collision = true;
                break;
            }

        }
        return collision;
    }

    function CheckForCompletedRows() {
        let rowsToDelete = 0;
        let startOfDeletion = 0;
        for (let y = 0; y < gBArrayHeight; y++) {
            let completed = true;
            for (let x = 0; x < gBArrayWidth; x++) {
                let square = stoppedShapeArray[x][y];
                if (square === 0 || (typeof square === 'undefined')) {
                    completed = false;
                    break;
                }
            }
            if (completed) {
                if (startOfDeletion === 0) startOfDeletion = y;
                rowsToDelete++;
                for (let i = 0; i < gBArrayWidth; i++) {
                    stoppedShapeArray[i][y] = 0;
                    gameBoardArray[i][y] = 0;
                    let coorX = coordinateArray[i][y].x;
                    let coorY = coordinateArray[i][y].y;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(coorX, coorY, 23,23);
                }
            }
        }
        if (rowsToDelete > 0) {
            score += 5;
            ctx.fillStyle = 'white';
            ctx.fillRect(310, 109, 140, 19);
            ctx.fillStyle = 'black';
            document.getElementById('current-score').innerHTML = score;
            
            //ctx.fillText(score.toString(), 310, 127);
            MoveAllRowsDown(rowsToDelete, startOfDeletion);
            
        }
    }

    function MoveAllRowsDown(rowsToDelete, startOfDeletion) {
        for (var i = startOfDeletion - 1; i >= 0; i--) {
            for (var x = 0; x < gBArrayWidth; x++) {
                var y2 = i + rowsToDelete;
                var square = stoppedShapeArray[x][i];
                var nextSquare = stoppedShapeArray[x][y2];
                if (typeof square === 'string') {
                    nextSquare = square;
                    gameBoardArray[x][y2] = 1;
                    stoppedShapeArray[x][y2] = square;
                    let coorX = coordinateArray[x][y2].x;
                    let coorY = coordinateArray[x][y2].y;
                    ctx.fillStyle = nextSquare;
                    ctx.fillRect(coorX, coorY, 23,23);
                    square = 0;
                    gameBoardArray[x][i] = 0;
                    stoppedShapeArray[x][i] = 0;
                    coorX = coordinateArray[x][i].x;
                    coorY = coordinateArray[x][i].y;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(coorX, coorY, 23,23);
                }
            }
        }
    }

    window.setInterval(function(){
        if(winOrLose != "Game Over"){
            MoveTetrominoDown();
        }
    },100);    

</script>


{%endblock%}